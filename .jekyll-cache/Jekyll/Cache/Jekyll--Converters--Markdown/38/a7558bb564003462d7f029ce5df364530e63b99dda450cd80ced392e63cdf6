I"<
<p>깃(git)을 꽤 오랫동안 썼지만 잘 모르는 기능 중에 하나가 리베이스(rebase)다. 사실 리베이스를 할 줄 알고 모름에 따라, 초급과 중급으로 구분된다고 해도 과언이 아니다. 리베이스를 꽤 오랫동안 썼지만, 주로 하는 것은 커밋 합치기(fixup, or squash)와 커밋 메시지 바꾸기(reword) 정도였다.</p>

<p>이번에 예전에 커밋한 내용을 수정할 일이 있어서 수정(edit) 기능을 처음 써봤다. 최종 목표는 이렇다.</p>

<ol>
  <li>이전에 커밋한 내용을 수정하고, 그 뒤에 연속되는 커밋에 변경 내용을 모두 반영한다.</li>
  <li>리베이스하기 전의 전체 커밋 로그를 리베이스 후에도 그대로 유지한다.</li>
</ol>

<p>말로는 쉬워보이지만, 2번이 정말 어려웠다.</p>

<p>예를 들어, <code class="highlighter-rouge">foo</code> -&gt; <code class="highlighter-rouge">bar</code> -&gt; <code class="highlighter-rouge">baz</code> 커밋 로그가 있다고 하자. 리베이스로 <code class="highlighter-rouge">foo</code> 커밋의 내용을 수정했는데 <code class="highlighter-rouge">bar</code>에서 충돌이 발생했다. <code class="highlighter-rouge">bar</code> 커밋에서 발생한 충돌을 해결하고 나면, <code class="highlighter-rouge">bar</code> 커밋은 <code class="highlighter-rouge">foo</code> 커밋으로 합쳐지고, <code class="highlighter-rouge">bar</code> 커밋 로그는 남지 않는다.</p>

<p>‘최종 커밋만 있으면 되지~’, ‘중간 커밋을 살리는 것이 무슨 의미가…?’라는 의문이 생길 수 있다. 맞다. 최종 커밋만 있으면 된다. 그런데, 나는 이번에 나올 책에서 챕터별로 예제 코드를 커밋했고, 커밋 로그 하나가 사라지면 챕터에 해당하는 소스코드의 이력이 사라지기 때문에 이 문제를 꼭 해결해야만 했다.</p>

<p>이 고생을 한 이유는 책을 쓰는 도중 라라벨 프레임워크의 수버전이(유의적 버전은 주.부.수로 쓴다) 변경되었고, 이번 버전 업에서는 라우트 사용법이 변경되었기 때문이다. 라우트는 웹 서버와 라라벨의 경계에 해당하는 부분이라 아주 아주 아주 중요할뿐더러, 책의 가장 첫 부분이기도 하다. 독자들은 새 버전의 프레임워크로 프로젝트를 시작할테고, 바뀐 사용법을 적용하지 않으면 책의 시작부터 작동하지 않는 소스코드를 만나게 되는 셈이다.</p>

<p>어쨌든… 이 포스트는 이 문제점을 해결한 이력이다.</p>

:ET