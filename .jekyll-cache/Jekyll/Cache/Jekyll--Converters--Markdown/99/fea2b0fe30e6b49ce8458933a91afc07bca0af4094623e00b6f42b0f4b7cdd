I"Rc<p><strong>상수는 변하지 않는 값</strong>, <strong>변수는 변하는 값</strong>이라고 배웠습니다. 객체에서도 마치 상수처럼 <strong>한 번 생성된 이후에 상태를 변경할 수 없는 객체를 불변(Immutable) 객체</strong>라고 합니다.</p>

<h2 id="1-불변성에-대한-개념-익히기">1. 불변성에 대한 개념 익히기</h2>

<p>아래 예제를 살펴 볼까요?</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
</code></pre></div></div>

<p>위 코드의 실행 결과는 <code class="highlighter-rouge">int(1)</code>입니다. 변수 <code class="highlighter-rouge">$b</code>에 변수 <code class="highlighter-rouge">$a</code>의 값을 할당한 후, <code class="highlighter-rouge">$b</code>에 새로운 값 <code class="highlighter-rouge">3</code>을 할당했습니다. 당연히 <code class="highlighter-rouge">$b</code>에는 <code class="highlighter-rouge">3</code>이 담겨 있고, <code class="highlighter-rouge">$a</code>에는 <code class="highlighter-rouge">1</code>이 담겨 있을 겁니다. 아주 쉽죠?</p>

<p>그런데, 객체 컨텍스트에서도 이 규칙이 그대로 적용될까요? 클래스는 변수와 함수로 구성된 템플릿이며, 객체란 그 템플릿에 필요한 값을 채워서 완성한 실체입니다. 여튼 위의 예제와 똑같이 동작해야 하지않을까요?</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">stdClass</span><span class="p">;</span>
<span class="nv">$a</span><span class="o">-&gt;</span><span class="na">name</span> <span class="o">=</span> <span class="s1">'Foo'</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$b</span><span class="o">-&gt;</span><span class="na">name</span> <span class="o">=</span> <span class="s1">'Bar'</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span>
<span class="c1">// class stdClass#696 (1) {</span>
<span class="c1">//   public $name =&gt;</span>
<span class="c1">//   string(3) "Bar"</span>
<span class="c1">// }</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="c1">// class stdClass#696 (1) {</span>
<span class="c1">//   public $name =&gt;</span>
<span class="c1">//   string(3) "Bar"</span>
<span class="c1">// }</span>
</code></pre></div></div>

<p>변수 <code class="highlighter-rouge">$b</code>에 <code class="highlighter-rouge">$a</code>에 담긴 객체를 그대로 할당한 후, <code class="highlighter-rouge">$b</code>의 <code class="highlighter-rouge">$name</code> 속성을 변경했습니다. <code class="highlighter-rouge">$b::name</code> 속성 값만 <code class="highlighter-rouge">"Bar"</code>로 바뀔 것이라 생각했지만, <code class="highlighter-rouge">$a::name</code> 속성 값도 <code class="highlighter-rouge">"Bar"</code>로 변경되어버렸습니다. <code class="highlighter-rouge">var_dump()</code>로 출력된 결과물에 객체 번호를 보면 힌트를 얻을 수 있습니다. <code class="highlighter-rouge">$a</code>와 <code class="highlighter-rouge">$b</code> 모두 <code class="highlighter-rouge">#696</code>으로 같습니다. 즉, 객체 <code class="highlighter-rouge">$b</code>는 객체 <code class="highlighter-rouge">$a</code>의 메모리 번지를 그냥 참조하고 있다고 볼 수 있습니다.</p>

<p>해결법은 의외로 간단합니다. 복제하는거죠. <code class="highlighter-rouge">clone</code> 키워드와 객체 번호가 <code class="highlighter-rouge">#696</code>, <code class="highlighter-rouge">#697</code>로 서로 다름을 확인해주세요.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">stdClass</span><span class="p">;</span>
<span class="nv">$a</span><span class="o">-&gt;</span><span class="na">name</span> <span class="o">=</span> <span class="s1">'Foo'</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="k">clone</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$b</span><span class="o">-&gt;</span><span class="na">name</span> <span class="o">=</span> <span class="s1">'Bar'</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span>
<span class="c1">// class stdClass#697 (1) {</span>
<span class="c1">//   public $name =&gt;</span>
<span class="c1">//   string(3) "Bar"</span>
<span class="c1">// }</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="c1">// class stdClass#696 (1) {</span>
<span class="c1">//   public $name =&gt;</span>
<span class="c1">//   string(3) "Foo"</span>
<span class="c1">// }</span>
</code></pre></div></div>

<!--more-->
<div class="spacer">• • •</div>

<h2 id="2-불변-밸류">2. 불변 밸류</h2>

<h3 id="21-carbon">2.1. Carbon</h3>

<p>라라벨 프로젝트에서 가장 쉽게 만날 수 있는 밸류 객체(Value Object, 값 객체)는 <code class="highlighter-rouge">Carbon</code> 입니다. 엘로퀀트 모델을 만들면 기본적으로 <code class="highlighter-rouge">created_at</code>, <code class="highlighter-rouge">updated_at</code>이란 속성이 추가되고, 이 속성에는 <code class="highlighter-rouge">Carbon</code> 객체가 할당됩니다.</p>

<p>객체의 이점을 얻기 위해서 보통 원시 타입(<code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">array</code>)을 밸류 객체로 바꿔서 사용하는데, 예를 들면, <code class="highlighter-rouge">string</code> 타입의 블로그 포스트 제목을 <code class="highlighter-rouge">Title</code> 객체를 만들어 사용하는 것 같은 것이죠. 예제가 현실적이지는 않지만, 앞서 말한 <code class="highlighter-rouge">Carbon</code>을 이용함으로써 다음과 같은 편리함이 더해집니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>php artisan tinker
<span class="c"># Psy Shell v0.8.3 (PHP 7.1.2 — cli) by Justin Hileman</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$article</span> <span class="o">=</span> Article::first<span class="o">()</span><span class="p">;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$article</span>-&gt;created_at <span class="o">=</span> <span class="nv">$article</span>-&gt;created_at-&gt;addDays<span class="o">(</span>5<span class="o">)</span><span class="p">;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$article</span>-&gt;save<span class="o">()</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>그런데 <code class="highlighter-rouge">Carbon</code>은 불변 밸류가 아닙니다.</strong> 아래 예제는 무시무시합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>php artisan tinker
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$now</span> <span class="o">=</span> Carbon<span class="se">\C</span>arbon::now<span class="o">()</span><span class="p">;</span>
<span class="c"># =&gt; Carbon\Carbon {#663</span>
<span class="c">#      +"date": "2017-06-04 03:00:22.272655",</span>
<span class="c">#    }</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$now</span>-&gt;addMonths<span class="o">(</span>1<span class="o">)</span><span class="p">;</span>
<span class="c"># =&gt; Carbon\Carbon {#663</span>
<span class="c">#      +"date": "2017-07-04 03:00:22.272655",</span>
<span class="c">#    }</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$now</span><span class="p">;</span>
<span class="c"># =&gt; Carbon\Carbon {#663</span>
<span class="c">#      +"date": "2017-07-04 03:00:22.272655",</span>
<span class="c">#    }</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">$now</code>라는 변수를 여러 곳에서 참조한다고 가정해보죠. 어떤 로직에서 <code class="highlighter-rouge">$now</code> 변수에 <code class="highlighter-rouge">addMonths()</code> API를 호출했다고 가정하죠. 그러면 그 뒤에 <code class="highlighter-rouge">$now</code> 변수를 참조하는 로직은 전부 한 달 뒤의 날짜 값을 사용하게 되는 겁니다. <code class="highlighter-rouge">Carbon</code>의 특성을 모르는 개발자가 이와 같이 코드를 짰을 때, <code class="highlighter-rouge">Carbon</code>의 특성에 대해 이해하고 있는 다른 개발자가 이 버그를 잡을 수 있을까요?</p>

<p>아참 해결방법은 <code class="highlighter-rouge">clone</code> 키워드를 이용하는 것입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>php artisan tinker
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$now</span> <span class="o">=</span> Carbon<span class="se">\C</span>arbon::now<span class="o">()</span><span class="p">;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$oneMonthFromNow</span> <span class="o">=</span> <span class="o">(</span>clone <span class="nv">$now</span><span class="o">)</span>-&gt;addMonths<span class="o">(</span>1<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="22-money">2.2. Money</h3>

<p>불변 객체는 한 번 생성된 이후에 상태를 변경할 수 없는 객체입니다. 아래 <code class="highlighter-rouge">Money</code> 클래스 예제를 살펴보면, <code class="highlighter-rouge">add()</code> 메서드는 다른 <code class="highlighter-rouge">Money</code> 객체를 인자로 받고, <code class="highlighter-rouge">$value</code> 속성의 상태를 변경하는 것이 아니라, 완전 새로운 <code class="highlighter-rouge">Money</code> 객체를 반환합니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="c1">// https://github.com/appkr/db-lock-poc/blob/master/core/Myshop/Common/Model/Money.php</span>

<span class="kd">class</span> <span class="nc">Money</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$value</span><span class="p">;</span>
    
    <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="kt">int</span> <span class="nv">$value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">=</span> <span class="nv">$value</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">function</span> <span class="nf">add</span><span class="p">(</span><span class="nx">Money</span> <span class="nv">$other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Money</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">+</span> <span class="nv">$other</span><span class="o">-&gt;</span><span class="na">getAmount</span><span class="p">());</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getAmount</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">function</span> <span class="nf">isEqualTo</span><span class="p">(</span><span class="nx">Money</span> <span class="nv">$other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">get_class</span><span class="p">()</span> <span class="o">===</span> <span class="k">__CLASS__</span>
            <span class="o">&amp;&amp;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">===</span> <span class="nv">$other</span><span class="o">-&gt;</span><span class="na">getAmount</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아래 팅커 출력 결과에서 객체의 번호가 <code class="highlighter-rouge">#683</code>, <code class="highlighter-rouge">#692</code>, <code class="highlighter-rouge">#694</code>로 모두 다름에 주목해야 합니다. 매번 다른 객체가 생성된다는 뜻이죠~</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>php artisan tinker
<span class="c"># Psy Shell v0.8.3 (PHP 7.1.2 — cli) by Justin Hileman</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$baseSalary</span> <span class="o">=</span> new Money<span class="o">(</span>100<span class="o">)</span><span class="p">;</span>
<span class="c"># =&gt; Money {#683}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$overtimeAllowance</span> <span class="o">=</span> new Money<span class="o">(</span>100<span class="o">)</span><span class="p">;</span>
<span class="c"># =&gt; Money {#692}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$baseSalary</span> <span class="o">===</span> <span class="nv">$overtimeAllowance</span><span class="p">;</span>
<span class="c"># =&gt; false</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$baseSalary</span>-&gt;isEqualTo<span class="o">(</span><span class="nv">$overtimeAllowance</span><span class="o">)</span><span class="p">;</span>
<span class="c"># =&gt; true</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$totalSalary</span> <span class="o">=</span> <span class="nv">$baseSalary</span>-&gt;add<span class="o">(</span><span class="nv">$overtimeAllowance</span><span class="o">)</span><span class="p">;</span>
<span class="c"># =&gt; Money {#694}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nv">$totalSalary</span>-&gt;getAmount<span class="o">()</span><span class="p">;</span>
<span class="c"># =&gt; 200</span>
</code></pre></div></div>

<p>밸류 객체는 객체의 속성 값이 모두 같다면 “같다”라고 할 수 있습니다. <code class="highlighter-rouge">User</code> 객체를 예로 들어 볼까요? 공교롭게도 어떤 <code class="highlighter-rouge">User</code>가 저와 같은 <code class="highlighter-rouge">$name</code>, <code class="highlighter-rouge">$age</code>를 가지고 있다고 가정해보죠? 그럼 두 <code class="highlighter-rouge">User</code>는 같을까요? 당연히 다르죠? 그런데, 2017-06-04 라는 값을 가진 <code class="highlighter-rouge">Date</code> 객체를 가정해보죠. 다른 <code class="highlighter-rouge">Date</code> 객체가 똑같이 2017-06-04라는 값을 가지고 있다면 둘은 같은걸까요? 예. 예로 든 <code class="highlighter-rouge">Date</code>는 밸류이고, <code class="highlighter-rouge">User</code>는 엔티티입니다.</p>

<h2 id="3-불변-엔티티">3. 불변 엔티티</h2>

<p>도메인 모델은 앤티티(Entity)와 밸류(Value, 값 객체)로 구분됩니다. 모델, 엔티티, 밸류, … 어려운 용어라 생각되지만, 따지고보면 결국은 클래스입니다. 앞서 클래스는 변수와 함수의 집합이라 했는데, 좀 더 구체적으로 말하면 다음과 같이 표현할 수 있습니다.</p>

<blockquote>
  <p>클래스란 Private 변수들과 그 Private 변수들을 사용하는 Public 함수들의 집합이다.</p>
</blockquote>

<p>엔티티는 고유 식별자를 가지고 있습니다. 엔티티는 생성된 후 식별자를 제외한 상태가 변경될 수 있습니다. “상태”라 표현한 것이 결국 클래스의 Private 변수들의 값이며, 이 Private 변수에는 다른 엔티티, 밸류 객체, 원시 타입 값들이 담기게 됩니다. 엔티티를 사용하는 클라이언트 클래스에서 엔티티의 Public 함수(API)를 호출하여 엔티티의 상태를 변경하겠죠~</p>

<p>밸류는 식별자가 없습니다. <code class="highlighter-rouge">Carbon</code>처럼 상태가 변경될 수도 있지만, 앞서 살펴본 대로 불변 객체를 사용하는 것이 더 나은 설계라고 알려져 있습니다. 앞서 살펴본 <code class="highlighter-rouge">Money</code> 밸류처럼 말이죠. 밸류 객체 역시, 해당 밸류를 상태로 사용하는 엔티티가 대상 밸류에 포함된 Public API를 호출함으로써 엔티티 자신의 상태를 변경할 겁니다.</p>

<p>객체로 생성되어 메모리에 살아 있는 동안 상태를 변경하고, 데이터베이스에 저장함으로써 다시 꺼내서 재생할 때까지 냉동 수면을 하게 됩니다.</p>

<p>그런데 불변 엔티티란 무엇일까요? 웹에서 정확한 정의를 찾지 못했습니다만, 앞서 살펴본 내용을 응용해보면, 최초 한번 생성후 상태가 변하지 않는 엔티티가 아닐까요? Private 변수에 담긴 값을 전혀 변경할 수 없고, 데이터베이스에서 삭제하기 전까지 돌부처 같이 처음 만든 상태를 그대로 유지하는 녀석이 아닐까요?</p>

<h3 id="31-필요성">3.1. 필요성</h3>

<p>지난 번 회사 프로젝트를 하면서 불변 엔티티의 필요성을 느꼈습니다.</p>

<ul>
  <li>생성 시점의 정보를 참조해서 계산한 값으로 채워진 모델일 때 (e.g. 청구서)</li>
  <li>그리고 한 번 생성된 후, 상태가 변경된다면 변경 이력을 추적해야 할 때</li>
  <li>시간이 지남에 따라 변경될 수 있는 값을 생성 시점의 값으로 고정시키고자 할 때 (e.g. 청구서 발행 시점의 피청구자 정보)</li>
</ul>

<h3 id="32-리서치">3.2. 리서치</h3>

<p>조사 결과 세 가지 정도의 구현 방식으로 정리됐습니다.</p>

<h4 id="321-상태-테이블과-변경-내역-저장-테이블-분리">3.2.1. 상태 테이블과 변경 내역 저장 테이블 분리</h4>

<p>최종 상태를 저장하는 메인 테이블과 변경 이력을 기록하는 테이블을 별도로 구성하는 방식입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Table: bills
+-------------------------------+
| 1 Bill <span class="k">for </span>User#1 <span class="k">for </span>2017-06 |
+-------------------------------+
| 2 Bill <span class="k">for </span>User#2 <span class="k">for </span>2017-06 |
+-------------------------------+

UPDATE bills SET base_charge <span class="o">=</span> 100 WHERE <span class="nb">id</span> <span class="o">=</span> 1<span class="p">;</span>

Tables:bill_history
+-------------------------------+
| History <span class="k">for </span>bill_id#1 <span class="o">{</span>...<span class="o">}</span>   |
+-------------------------------+
| History <span class="k">for </span>bill_id#1 <span class="o">{</span>...<span class="o">}</span>   |
+-------------------------------+

INSERT INTO bill_history <span class="o">(</span>bill_id, changed, changed_by, changed_at, ...<span class="o">)</span> 
VALUES <span class="o">(</span>1, <span class="s2">"{original:{base_charge:90}, changed:{base_charge:100}}"</span>, <span class="s2">"Foo"</span>, NOW<span class="o">()</span>, ...<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="322-하나의-엔티티에-대해-여러-레코드를-기록">3.2.2. 하나의 엔티티에 대해 여러 레코드를 기록</h4>

<p>3.2.1의 두 개 테이블을 하나로 합쳐서 상태를 저장하는 방식입니다. <code class="highlighter-rouge">UPDATE</code> 쿼리는 없고, 오직 <code class="highlighter-rouge">INSERT</code>만 허용합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Table: bills
+-------------------------------+
| Last state of Bill#1          |
+-------------------------------+
| Past state of Bill#1          |
+-------------------------------+
| Last state of Bill#2          |
+-------------------------------+
SELECT <span class="k">*</span> FROM bills WHERE entity_id <span class="o">=</span> 1 ORDER BY version DESC LIMIT 1<span class="p">;</span>

INSERT INTO bills <span class="o">(</span>entity_id, version, subscriber_id, term, base_charge, 
    valud_added_charge, discount_amout, fulfilled, last_modified_by, ...<span class="o">)</span>
VALUES <span class="o">(</span>1, 2, 1, <span class="s2">"2017-06"</span>, 100, 100, 50, <span class="nb">false</span>, <span class="s2">"Foo"</span>, ...<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="323-이벤트-소싱">3.2.3. 이벤트 소싱</h4>

<p>이벤트를 데이터 소스로 사용하는 디자인 패턴입니다. 이벤트 데이터를 스택에 쌓아 놓고, 이벤트 리플레이를 통해 현재 상태를 계산해 냅니다. 핵심 함수와 전체 개념은 아래와 같습니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">decide</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="n">state</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ListEvent</span>
<span class="nf">apply</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">event</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">state</span>
<span class="nf">replay</span><span class="o">(</span><span class="n">initialState</span><span class="o">,</span> <span class="nc">ListEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">version</span><span class="o">)</span>
</code></pre></div></div>

<p><img src="//blog.leifbattermann.de/wp-content/uploads/2017/04/event-sourcing.svg" alt="" /></p>

<p>웹에서 만난 전문가들도 이벤트 소싱의 이점을 충분히 누릴 수 있는 도메인에만 도입할 것을 권장합니다. 포스트 끝에 참고 자료들을 기록해 두었습니다.</p>

<h3 id="33-예제-프로젝트">3.3. 예제 프로젝트</h3>

<p>매월 주기적으로 핸드폰 청구서를 발행하는 예제를 통해서 불변 엔티티를 구현해 보고자 합니다. 데이터를 자주 변경하는 도메인이 아니므로 3.2.2 방식으로 구현하려고 합니다.</p>

<p>틈틈이 작업 중인 저장소입니다. <a href="https://github.com/appkr/immutable-entity-poc">https://github.com/appkr/immutable-entity-poc</a></p>

<hr />

<h2 id="읽어보면-좋을만한-자료들">읽어보면 좋을만한 자료들</h2>

<ul>
  <li><a href="https://ocramius.github.io/doctrine-best-practices">doctrine-best-practices</a></li>
  <li><a href="//ziobrando.blogspot.kr/2010/06/about-entities-aggregates-and-data.html">About Entities, Aggregates and Data Duplication.</a></li>
  <li><a href="//www.ntaso.com/why-i-dont-use-value-objects-in-laravel-anymore/">Why I Don’t Use Value Objects in Laravel Anymore</a></li>
  <li><a href="//www.ntaso.com/value-objects-laravel-eloquent/">Value Objects in Laravel 5 with Eloquent Done Right</a></li>
  <li><a href="https://www.slideshare.net/madvirus/event-source">이벤트 소싱 학습 내용 공유 by 최범균</a></li>
  <li><a href="//blog.leifbattermann.de/2017/04/21/12-things-you-should-know-about-event-sourcing/">12 Things You Should Know About Event Sourcing</a></li>
  <li><a href="https://msdn.microsoft.com/magazine/mt422577">Cutting Edge - Event Sourcing for the Common Application</a></li>
  <li><a href="//blog.aliencube.org/ko/2015/11/12/building-applications-on-cloud-with-event-sourcing-pattern-and-cqrs-pattern/">이벤트 소싱 패턴과 CQRS 패턴을 적용해서 클라우드상에서 유연하게 앱 개발하기</a></li>
  <li><a href="https://github.com/nWidart/Laravel-broadway">Laravel adapter for Broadway.</a></li>
</ul>
:ET