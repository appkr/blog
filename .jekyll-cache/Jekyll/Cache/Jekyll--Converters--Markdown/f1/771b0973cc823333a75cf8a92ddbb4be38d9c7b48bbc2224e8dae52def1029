I"&)<p>라라벨과 루멘, PHP 날코딩간의 성능 비교를 해 보신 분들이 없는 것 같아 직접 해 봤다. <strong>결론은 뻔하지만, PHP 날코딩이 가장 빠르고, 메모리 사용량도 적다. 프레임워크를 써야 이유는 다른 곳에 있으니, 이 실험 결과만 보고 오해나 곡해하지 마시기 바란다.</strong></p>

<p><strong><code class="highlighter-rouge">주의</code></strong> 이 실험은 다른 PHP 프레임워크 또는 다른 플랫폼의 프레임워크와 라라벨 또는 루멘의 성능을 비교하기 위한 것이 아니다(다른 PHP 프레임워크와의 비교는 <a href="//taylorotwell.com/how-lumen-is-benchmarked/">“How Lumen Is Benchmarked”</a>를 참고하라). <strong>이 실험은 라라벨과 루멘의 기본적인 속도와 필요 리소스를 측정해 봄으로써, PHP 날코딩의 성능과 프레임워크가 제공하는 이점 간의 트레이드오프(trade-off)에 대한 의사 결정 포인트를 제공하기 위한 목적으로 수행하였다.</strong></p>

<!--more-->
<div class="spacer">• • •</div>

<h2 id="1-실험-환경">1. 실험 환경</h2>

<p>다음 머신에서 실험했다.</p>

<ul>
  <li>macOS Sierra 10.12.1</li>
  <li>2.7 GHz Intel Core i5</li>
  <li>8GB 1867 MHz DDR3</li>
  <li>SSD</li>
</ul>

<p>사용한 소프트웨어 버전은 다음과 같다.</p>

<ul>
  <li>PHP 7.0.11 with Xdebug, without OPcache</li>
  <li>MySQL 5.7.15</li>
  <li>Laravel Valet 1.1.22 (로컬 웹 서버)</li>
</ul>

<h2 id="2-실험-방법">2. 실험 방법</h2>

<p>다음과 같이 실험했다.</p>

<ul>
  <li>웹 브라우저에서 테스트를 위한 URL 엔드포인트를 각 시나리오별로 총 5회 방문했고, 아웃라이어 2개는 버리고 남은 3개만 이용했다.</li>
  <li>해당 엔드포인트는 MySQL 데이터베이스에서 2개의 레코드를 가져와서 HTTP 응답을 내 보내는 일을 하는데, HTTP 응답을 반환하기 직전에 현재까지의 1) 실행 시간, 2) 메모리 사용량을 로그에 기록하였다.</li>
</ul>

<h3 id="21-mysql-테이블-레코드">2.1. MySQL 테이블 레코드</h3>

<p>MySQL에 저장된 2개의 레코드를 팅커(라라벨 내장 REPL) 콘솔에서 확인했봤다.</p>

<p><a href="/images/2016-11-07-img-01.png"><img src="/images/2016-11-07-img-01.png" alt="Test Vector" /></a></p>

<h3 id="22-테스트-코드">2.2. 테스트 코드</h3>

<p>라라벨 기준으로 성능 측정 코드는 다음과 같다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="c1">// index.php</span>

<span class="nb">define</span><span class="p">(</span><span class="s1">'LARAVEL_START'</span><span class="p">,</span> <span class="nb">microtime</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
</code></pre></div></div>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="c1">// routes/web.php</span>

<span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nv">$todos</span> <span class="o">=</span> <span class="nx">App\Todo</span><span class="o">::</span><span class="na">all</span><span class="p">();</span>

    <span class="nb">Log</span><span class="o">::</span><span class="na">info</span><span class="p">(</span><span class="s1">'metric'</span><span class="p">,</span> <span class="p">[</span><span class="nx">performance</span><span class="p">()]);</span>

    <span class="k">return</span> <span class="nv">$todos</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">performance()</code> 함수는 이렇게 생겼다. 할당된 메모리 양이 아니라, 사용한 메모리 양으로 측정했다(<a href="//php.net/manual/en/function.memory-get-usage.php"><code class="highlighter-rouge">memory_get_usage()</code></a>).</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> <span class="c1">// app/helpers.php</span>

<span class="k">function</span> <span class="nf">performance</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">implode</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span> <span class="p">[</span>
        <span class="s1">'처리시간(ms): '</span> <span class="o">.</span> <span class="p">(</span><span class="nb">microtime</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="o">-</span> <span class="nx">LARAVEL_START</span><span class="p">),</span>
        <span class="s1">'메모리(MB) : '</span> <span class="o">.</span> <span class="nb">memory_get_usage</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span>
        <span class="s1">'CPU(%): '</span> <span class="o">.</span> <span class="nb">sys_getloadavg</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-실험-결과">3. 실험 결과</h2>

<h3 id="31-라라벨">3.1. 라라벨</h3>

<p><code class="highlighter-rouge">laravel/framework 5.3.19</code> 버전을 이용했다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th style="text-align: right">처리시간(ms)</th>
      <th style="text-align: right">메모리(MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: right">48.988103867</td>
      <td style="text-align: right">7.369736000</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: right">43.443918228</td>
      <td style="text-align: right">7.369736000</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: right">43.838024139</td>
      <td style="text-align: right">7.369736000</td>
    </tr>
    <tr>
      <td>평균</td>
      <td style="text-align: right">45.343995094</td>
      <td style="text-align: right">7.369736000</td>
    </tr>
  </tbody>
</table>

<h3 id="32-루멘">3.2. 루멘</h3>

<p><code class="highlighter-rouge">laravel/lumen-framework 5.3.1</code> 버전을 이용했다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th style="text-align: right">처리시간(ms)</th>
      <th style="text-align: right">메모리(MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: right">23.682117462</td>
      <td style="text-align: right">4.800936000</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: right">23.600816727</td>
      <td style="text-align: right">4.800936000</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: right">25.380134583</td>
      <td style="text-align: right">4.800936000</td>
    </tr>
    <tr>
      <td>평균</td>
      <td style="text-align: right">24.163961411</td>
      <td style="text-align: right">4.800936000</td>
    </tr>
  </tbody>
</table>

<h3 id="33-php-날코딩">3.3. PHP 날코딩</h3>

<p>날 코딩이라 하지만, 컴포저와 PDO를 사용하고 MVC 구조로 짠 코드다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th style="text-align: right">처리시간(ms)</th>
      <th style="text-align: right">메모리(MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: right">3.256082535</td>
      <td style="text-align: right">0.916032000</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: right">4.014015198</td>
      <td style="text-align: right">0.916032000</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: right">3.664970398</td>
      <td style="text-align: right">0.916032000</td>
    </tr>
    <tr>
      <td>평균</td>
      <td style="text-align: right">3.560066223</td>
      <td style="text-align: right">0.916032000</td>
    </tr>
  </tbody>
</table>

<h2 id="4-결론">4. 결론</h2>

<p>속도나 메모리 사용량 면에서 PHP 날코딩이 확실히 유리하다. 이 테스트 기준으로 2GB 메모리 머신에서 PHP 날코딩이 1초당 610,649개의 요청을 처리할 수 있다면(2000/0.92 * 1000/3.56), 라라벨은 5,895개의 요청을 처리할 수 있다(2000/7.37 * 1000/45.34).</p>

<p>물론, 현실 세계에서 이런 간단한 서비스는 없으므로, 한 요청당 수십 MB의 메모리를 사용하고 수백 ms의 처리 시간이 걸린다. 운영 환경에서는 아파치나 엔진엑스를 사용하고, Xdebug를 끄고, OPcache를 켜서 성능을 향상시킬 수 있다.</p>

<p>프레임워크의 장점으로 생산성, 안정성, 보안을 들 수 있다. 수퍼 개발자가 있어 열 명이 해야 할일을 혼자서 처리하고, 해킹에 뚫릴 일이 전혀 없고 유지보수 하기도 편리한 자체 서비스 프레임워크를 직접 개발할 수 있다면, 라라벨과 루멘과 같은 프레임워크를 쓸 필요 없다.</p>

<p>경험적으로 수퍼 개발자에 의존하는 서비스 운영은 절대 바람직하지 않다. 수퍼 개발자가 자신의 지위를 악용하거나, 아프거나 퇴사라도 하는 순간 서비스는 한 순간에 무너진다.</p>

<p>컴퓨터의 성능은 좋아졌고, 가격은 싸져서 스케일 업(scale-up)이 쉬워졌다. 또, 쉽게 스케일 아웃(scale-out)할 수 있는 클라우드도 널렸다. <strong>개발자 한 명 채용하는 비용보다 컴퓨터 비용이 훨씬 싸다는 점을 잊지 말자. 좋은 서버 쓰고 안정적인 코드를 빨리 개발하는 것이 더 현명하다.</strong></p>

<p>반면 서비스가 궤도에 올라 사용자가 늘고 1ms와 1KB라도 쥐어 짜야 하는 상황이라면 자체 프레임워크 개발을 고려해볼 만한다. 물론 성능이 더 좋은 플랫폼으로 갈아 타는 방법도 있다. <strong>서비스를 살리기 위해 스택을 버려야지, 스택을 살리기 위해 서비스를 버리는 어리석음을 범하지 말라</strong>. 라라벨이나 루멘은 범용 프레임워크이므로 최적화가 필요한 초대형 서비스에는 적합하지 않다는 생각이 든다.</p>
:ET