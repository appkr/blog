---
layout: post
title: 모바일의 버스 구조
date: '2010-02-14 14:04:37 +0900'
categories:
- undisclosed-posts
tags:
- bux
- cpu
---

[모바일의 버스 구조](http://www.androidpub.com/53550)
  
 
  
그냥 잡글이나 하나 써보려고 합니다.. 그림까지 그리면 좋을텐데.. 찾아보니까 남은게 없네요.. 
  
   일단 PC는 워낙이나 많이들 알고 계시죠.. CPU가 있고, 캐쉬가 여기 연결되어 있습니다.. 캐쉬 미스가 발생하면 메모리 컨트롤러에 접근해서, 데이터를 읽어옵니다.. PC는 성능이 최고 우선 순위라서, 무조건 클럭이 높고, 레이턴스가 적도록 셋팅되어 있습니다.. SDR 메모리와는 다르게 DDR메모리들은 데이터의 대역폭이 크고, 데이터의 변환 속도가 빠르기 때문에 메모리와 메모리 컨트롤러 사이에 DLL이란걸 사용해서 클럭을 동기화하고 있습니다.. 
  
   주변 기기와는 PCI버스, PCI-EXPRESS등으로 연결되어 있고, UART나 USB등의 저속 디바이스들은 PCI의 한 디바이스로 연결되어 있습니다.. 이걸 South Bridge라고 부르죠.. PCI는 슬레이브로도 마스터로도 연결됩니다.. 마스터란 얘기는 PCI Device가 데이터 전송 요청을 한다는 의미입니다.. 데이터 전송의 주체가 PCI가 되기 때문에, CPU가 개입할 필요가 없어서, CPU의 자원을 소모하지 않는다는 거죠.. PCI의 경우에는 대역폭이 133MB/s밖에 되지 않았지만 PCI-EXPRESS는 1GB/s정도 되는것 같습니다.. 엄청난 대역폭이죠.. 
  
   사실 System의 대역폭은 엄청나지만.. 성능이 최고 우선이라, PCI-E에 연결된 그래픽 카드들은 별도의 프레임 버퍼를 가지고 있습니다.. 화면 이미지를 저정하고 있다가, 화면에 뿌려주는 건데, 대역폭이 상당합니다.. 예전에 ET4000이라고 유명한 그래픽 카드가 있었는데, 이 카드가 유명해진건, 프레임 버퍼를 두조각으로 가지고 있다가, 하나는 화면 위쪽, 다른 하나는 화면 아래쪽을 담당합니다.. 화면 아래쪽을 보여주는 동안에는 위쪽을 자유롭게 엑세스 하고, 화면 위쪽을 보여주는 동안에는 아래쪽을 자유롭게 엑세스 하도록 해서, 경쟁자들을 압도하는 성능을 보여줘서, 유명해졌습니다.. 사실, 화면에 뿌려주는 대역폭이 너무 크다보니, 이전에 그래픽 카드들은 화면에 뿌리지 않는 시간, 즉 Vertical Sync동안만 프레임 버퍼에 접근할수 있었습니다.. 
  
   PC의 경우 비효율적인 부분이 상당히 많은데, 
  
   1. 캐쉬의 적중율이 99%나 되기 때문에, 메모리가 대부분의 시간동안 아무일도 안함에도 클럭은 점점점점 높아집니다.
  
   2. PCI나 PCI-E가 마스터 기능이 있슴에도 불구하고, 대부분은 슬레이브 모드로 돌아갑니다.. 예를 들어 Realtek LAN의 경우, 데이터를 항상 CPU가 하나 하나 써줘야 합니다.. Notebook에 들어가는 무선 랜 카드들도 마찬가지로 CPU가 데이터를 하나 하나 써줘야 해서, CPU점유율이 높고 속도도 잘 안 납니다.. 제가 예전에 마스터 기능을 이용하는 보드를 짤때 뭐가 잘 안되어서 다른 회사거 Logic Analyzer로 찍어봤는데, 마스터 기능 쓰는 제품이 하나도 없었습니다.. –.- 
  
   3. 게다가 PC는 원가 부담을 줄이고, 문제의 소지를 없애고자, 모든 컨트롤을 CPU에 집중시켜 버려서, 마스터 기능이 있어도 중간 중간 제어는 CPU가 다 해줘야 합니다.. USB같은 경우는 아예 CPU가 다 통제해 줘야 하죠.. 그래도 요즘은 클럭이 올라가서 많이 괜찮아 졌습니다.. 
  
   이에 비해서, 모바일쪽 프로세서들은 너무나 많은 제약 사항이 있습니다.. 일단 클럭 문제인데, 클럭을 높이 올리기 힘듭니다.. 발열이 가장 큰 문제인데, 적절하게 쿨링을 할수 있는 방법이 없습니다.. 핸폰의 경우, 별로 많지 않은 회로인데도, 통화가 시작되면 분당 3도씩 올라간다던가 뭐.. 그런 통계를 본적 있습니다.. 정확한 숫자는 기억 안 납니다.. -.- 그리고, 한정된 공간에 다 집어넣어야 되다보니, 메모리도 하나 가지고 공유하는 수 밖에 없습니다.. 그러다보니, CPU도 후져, 메모리도 후져.. 전력도 약해.. 쉬운게 없습니다.. 
  
   메모리를 예로 들면, 모바일 DDR은, 전력 소모 때문에, 클럭 동기화 하는 회로가 빠져 있습니다.. 그 DLL인가 하는 놈이 250mW인가 먹습니다.. (어느 페이퍼를 보니).. 250mW면 엄청난 거라서, 절대로 집어넣을 수가 없습니다.. -.- 이거 빼면 클럭 동기화를 못하니까, 메모리 컨트롤러랑 메모리랑 클럭이 막 왔다 갔다 합니다.. 처음에 칩이 차가울땐 거의 동기화가 되다가, 열받으면서 점점 어긋나기 시작합니다.. -.- 그래서, 속도를 높이는데도 한계가 있고, 또 주기적으로 얼마나 틀어졌는지 메모리 컨트롤러에서 확인해야 됩니다.. 제가 모바일 DDR 스펙도 정해지기 전에 이 회로 만든다고 시껍 했습니다.. 
  
   또, 동작 온도가 높다보니, 내부 DRAM의 축전기 동작이 좋지 않아, 리프레시도 자주 해야 됩니다.. 이게 심할땐 동작시간의 20% 이상을 리프레시가 먹습니다.. 100MHz로 동작하는 DDR이 예를 들어 400MB/s쯤 나온다면 80MB/s가 사라지는 거죠.. 그런데, 이런 메모리가 하나 밖에 없죠.. 
  
   보통 스맛폰이라고 하면, 8M 카메라 정도 달려 있는데, 사진 찍고 나서, CMOS에서 데이터를 쭉 읽어올때 빨리 못 읽어오면 중간에 픽셀을 놓치는 일이 생겨서, 그림 깨집니다.. 그럼 뭐.. 빨리 읽어와야죠.. 근데, CPU랑 메모리를 공유한단 말이죠.. 게다가 모바일 CPU는 캐쉬크기도 작아서 캐쉬 성공율도 낮고, 메모리에서 자주 읽어와야 됩니다.. 카메라에서 데이터 읽어오는 동안은.. 항상 CPU랑 카메라랑 싸웁니다.. 만약 비디오 녹화라도 돌려버리면.. 이땐 CPU도 바쁘고, 카메라도 바쁩니다.. –.-
  
   PC는 대역폭이 워낙 커서, 크게 신경 안 써도 잘 돕니다.. 게다가, 깨질것 같으면 여기저기 버퍼를 많이 박는데, 모바일은 그게 다 돈이고 전력소모라서 그렇게 못하거든요.. 그러니까 굉장히 신경써서 만듭니다.. 예를 들면 모바일 프로세서의 버스 구조에선 QoS가 중요해서 앞에서 언급한 카메라를 돌리는 경우, Time Division Arbitration 방식을 씁니다.. 어떤 시간을 할당해서 그시간엔 특정 디바이스가 메모리를 쓸수 있도록 해주는 거죠.. 카메라의 대역폭은 정해져 있으니, 카메라에서 할당하는 겁니다.. 근데 CPU란 놈도 중요 하잖아요.. 그러니까 CPU는 TDA방식을 뛰어넘을수 있도록 해 주는데, 너무 많이 가로채면 사진이 깨지니까 일정 만큼만 가로챌수 있도록 또 카운터를 답니다.. –.- 
  
   거기에 어떤 놈은 대역폭이 남으면 다 소모하는 놈들도 있어서 그런놈들은 제일 마지막 순위로 배치합니다.. 이게 항상 동작 모드가 동일한건 아니라서, 어떤 경우엔 버스 구조를 이렇게 바꿔서, CPU에 조금더 많은 대역폭을 할당했다가, 동영상 촬영으로 가면 다른 모드로 바꾸고.. 그런 동작이 들어가줘야 꽤나 부드럽게 돌아갑니다.. 
  
   또, DMA엔진 같은것들도 꽤나 고급입니다.. 인텔의 StrongARM사용한 칩이 아마 최초인것 같은데, Contents monitoring DMA던가, 버퍼 레벨을 자동으로 체크해서 전송하는 엔진을 썼습니다.. UART나 USB나 데이터 전송할거 많으면 CPU더러 테스크를 주는게 아니라, DMA가 알아서 하는 거죠.. 
  
   제가 만들었던 놈은 더 고급이라서, 버퍼 레벨을 자동으로 체크하는 것 뿐만 아니라, 여러개의 채널을 두고 각각 관계 설정도 할수 있었습니다.. 왜냐하면 데이터를 읽어올때 특별한 프로그램을 실행해야 하는 경우가 있거든요.. 예를 들면 NAND Flash.. 읽을땐 읽는 명령을 보내줘야 됩니다.. 따라서, Ch0엔 제어 명령을 담고, Ch1엔 데이터 전송 명령을 담아서, Ch1을 Ch0에 Dependancy를 걸어둡니다.. 
  
   버퍼가 비면, Ch0가 활성화 되고, ch0가 완료되면 ch1이 실행되어서 데이터를 전송하는데 원하는 량이 전송될때까진 CPU가 개입할 필요가 없습니다.. 이 테스크는 버스 사용 순위에서 제일 하단으로 할당됩니다.. 안 그러면 데이터 전송하는 놈이 버스 대역폭을 다 사용해 버리거든요.. 잘만 사용하면 Mp3재생을 위해서 Nand에서 일어오는 동작을 노래 끝날때까지 CPU가 개입할 일이 하나도 없습니다.. 
  
   그래서 보통 모바일의 버스는 보통 50~60%이상 빡세게 돌아갑니다.. 또 보통 모니터링 회로가 있어서, 활용도가 떨어지면 클럭을 낮춥니다.. -.- 제가 만든 놈도, 평균 레이턴시, 최대 레이턴시, 특정 기간안에 몇개의 액세스가 실행되었는지 CPU로 보고하는 체계가 있었죠.. 클럭을 낮출수 있으면 그 자체에서 전력 소모가 줄어들지만.. 전압도 낮출수 있어서 두가지로 전력이 줄어듭니다.. 그에 비하면 PC는.. 너무 쉽다고나 할까요.. Speedstep이란거.. 모바일에는 더 적극적인 전압 관리 방식이 몇년전부터 있었습니다..
